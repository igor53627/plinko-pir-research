package client

// QueryRequest represents the query sent to the server
// In the full protocol, this consists of two sets S and S_hat
// such that S \Delta S_hat = {x} (conceptually, or similar structure).
// Actually, Plinko uses the standard "punctured set" or similar approach?
// Paper Section 5.2:
// Query(x):
// 1. Find hint H[j] such that x \in P_j (using iPRF inverse).
// 2. Let P_j be the set of indices in block j.
// 3. Construct query sets.
// The server computes parity of S and S_hat.
// Wait, the server implementation I analyzed earlier just takes a PRF key and expands it.
// That was the "Simple Offline-Online PIR" or a simplified version.
// The FULL Plinko protocol (Section 5.2) says:
// "The client sends (S, S_hat) to the server."
// "S is a random subset of [c] of size c/2."
// "S_hat = S \oplus {j}" (symmetric difference?)
// Actually, let's look at the paper again.
// "The client picks a random set S \subset [c] of size c/2."
// "Let j be the index of the hint containing x."
// "Let S_hat = S \Delta {j}."
// "Server computes a_S = \bigoplus_{k \in S} H[k]?" No, server doesn't have hints.
// Server has database D.
// Server computes answers for blocks?
// No, Plinko is single-server.
// The server computes parities of *database entries* indexed by the sets.
// But the sets S and S_hat are sets of *blocks* (hints)?
// No, S and S_hat are sets of *indices*?
// Let's re-read the Query algorithm in the paper carefully.

// Re-reading Paper Section 5.2 (Query):
// 1. Client finds j such that x \in P_j.
// 2. Client picks random S \subset [m] (indices of hints/blocks).
//    Actually, the query is about *blocks*.
//    The server computes parities of blocks.
//    But the server stores D as a flat array.
//    The "blocks" P_j are defined by the iPRF.
//    P_j = { z | F(k, z) = j }.
//    So the server needs to sum D[z] for all z in P_j?
//    That would be slow (O(n)).
//    The server must be able to compute parities efficiently.
//    Ah, the server *precomputes* block parities? No, that's storage heavy.
//    Wait, Plinko claims O(n/r) server time.
//    If block size is w, and there are c blocks.
//    Server time is O(w).
//    This implies the server only touches O(w) entries.
//    How?
//    The query sends a "punctured set" of blocks?
//    Actually, the "Simple Offline-Online PIR" (lines 413-447) uses PRFs to define sets.
//    The server expands the PRF to get a set of indices.
//    The *full* Plinko protocol (Section 5.2) builds on this.
//    "The server sees a random partitioning..."
//    The query consists of a PRF key (defining a set of blocks?) or explicit indices?
//    If the server implementation expects a PRF key (as analyzed), it expands it to `setSize` indices.
//    This corresponds to ONE set.
//    The client probably sends TWO queries (or one query that implies two sets).
//    If the server code `HandleFullSetQuery` takes ONE key and returns ONE parity,
//    then the client must call it twice?
//    Or the client sends one key, and the server computes parity.
//    But how does that retrieve x?
//    D[x] = Hint[j] \oplus Answer.
//    For this to work, Answer must be parity of (P_j \setminus {x})?
//    Or Answer = Parity(P_j) \oplus D[x]?
//    If Hint[j] = Parity(P_j), then D[x] = Hint[j] \oplus Answer implies Answer = Parity(P_j \setminus {x}).
//    So the server must compute parity of P_j \setminus {x}.
//    But the server doesn't know x.
//    And P_j is pseudorandom.
//
//    Actually, the standard "hint-based" PIR works like this:
//    Hint H = Parity(S).
//    Client wants x.
//    Client finds S such that x \in S.
//    Client asks server for Parity(S \setminus {x}).
//    Server computes it.
//    Client computes H \oplus Parity(S \setminus {x}) = D[x].
//
//    But the server doesn't know x.
//    So the client sends a set S' = S \setminus {x}.
//    But if S is pseudorandom (generated by PRF), client can't just remove x without revealing x (by the hole in the set).
//    UNLESS S is constructed such that x is the *only* difference between S and some other random set?
//
//    In Plinko/Piano:
//    The client has hints for *many* sets.
//    Client finds a set S_j (hint H_j) that contains x.
//    Client sends a query that looks random but is related to S_j.
//    Actually, in Piano (and Plinko), the client sends a *fresh* PRF key k_q.
//    This generates a fresh set S_q.
//    The server computes Parity(S_q).
//    This doesn't help unless S_q is related to S_j.
//
//    Wait, the "Multipoint" nature or the "Backup" hints?
//    Let's check the server code again.
//    `HandleFullSetQuery` expands a PRF key to `setSize` indices.
//    It returns parity of those indices.
//    This looks like the server is just computing parity of a random set.
//
//    Maybe the client does:
//    1. Find hint H_j for set P_j containing x.
//    2. Construct a query for P_j \setminus {x}?
//       If the server only accepts PRF keys, we can't puncture the set arbitrarily.
//       Unless we use "Punctured PRFs"? (Not mentioned as main primitive).
//
//    Alternative:
//    The server supports `HandleSetParityQuery` (explicit indices).
//    The client could send P_j \setminus {x} explicitly.
//    But that's O(w) communication (large).
//    Plinko claims low communication.
//
//    Let's look at the paper's "Query" algorithm (Fig 5 or text).
//    "The client sends a multipoint query..."
//    "The client sends a set of keys..."
//
//    Actually, the server implementation has:
//    `/query/fullset` -> PRF key -> Parity.
//    `/query/setparity` -> Indices -> Parity.
//
//    Maybe the client uses `/query/setparity` for the "correction" or "punctured" part?
//    If `setSize` is small (sqrt(n)), then sending indices is O(sqrt(n)), which matches O(n/r) if r=sqrt(n).
//    So explicit indices ARE allowed.
//
//    So the strategy is:
//    1. Client finds hint H_j for set P_j containing x.
//    2. Client computes P_j using iPRF forward (locally).
//    3. Client removes x from P_j to get P_j'.
//    4. Client sends P_j' to server using `/query/setparity`.
//    5. Server returns p' = Parity(P_j').
//    6. Client computes D[x] = H_j \oplus p'.
//
//    Is this private?
//    Server sees P_j \setminus {x}.
//    This is a set of size w-1.
//    It looks like a random set of size w-1.
//    Does it reveal x?
//    x is the missing element.
//    But P_j is a *random* set containing x.
//    To the server, it's just a random set of size w-1.
//    The "hole" is only visible if the server knows P_j *should* have had x.
//    But P_j is defined by a key k_j (part of iPRF).
//    The server *doesn't know* which k_j was used.
//    The client just sends indices.
//    So the server sees a random set of indices.
//    Since P_j is uniform random, P_j \setminus {x} is also uniform random (conditioned on size).
//    So this seems secure *for one query*.
//
//    However, if the client reuses hints, privacy degrades.
//    That's why we need backup hints and updates.
//
//    So, for `online.go`:
//    Query(x):
//    1. Find hint j such that x \in P_j (using iPRF Inverse).
//    2. Reconstruct P_j = { z | F(k, z) = j }.
//       Wait, iPRF Inverse gives { z | F(k, z) = j }.
//       So we can reconstruct P_j efficiently!
//    3. Remove x from P_j.
//    4. Send P_j \setminus {x} to server.
//
//    This matches the server's capabilities (`/query/setparity`) and the paper's logic (using iPRF inverse to find/construct the set).
//
//    The `HandleFullSetQuery` (PRF based) might be for *generating* hints or for a different variant (like Piano where you stream updates?).
//    But for the core query, explicit indices (punctured set) seems correct for the "download" phase.
//
//    Wait, if communication is O(sqrt(n)), and we send sqrt(n) indices (each 8 bytes), that's okay.
//
//    Let's implement this logic.

type QueryRequest struct {
	Indices []uint64
}

func (c *Client) Reconstruct(responseParity [4]uint64, hint *Hint) [4]uint64 {
	// D[x] = Hint[j] \oplus Parity(P_j \setminus {x})
	var result [4]uint64
	for k := 0; k < 4; k++ {
		result[k] = hint.Parity[k] ^ responseParity[k]
	}
	return result
}

// Query generates a query for index x
// Returns the request and the hint used (for reconstruction)
func (c *Client) Query(x uint64) ([]uint64, *Hint, bool) {
	// 1. Try Primary Hint (via iPRF)
	j := c.iprf.F(x)

	if j < uint64(len(c.hints)) && !c.hints[j].Used {
		hint := &c.hints[j]
		hint.Used = true // Mark as consumed

		// Reconstruct set P_j = { z | F(z) = j }
		members := c.iprf.Inverse(j)

		indices := make([]uint64, 0, len(members))
		found := false
		for _, z := range members {
			if z == x {
				found = true
				continue
			}
			indices = append(indices, z)
		}

		if found {
			return indices, hint, true
		}
	}

	// 2. Try Backup Hints
	for i := range c.backupHints {
		hint := &c.backupHints[i]
		if hint.Used {
			continue
		}

		// Check if x is in this hint's set
		found := false
		for _, idx := range hint.Indices {
			if idx == x {
				found = true
				break
			}
		}

		if found {
			hint.Used = true

			// Construct query: S \setminus {x}
			indices := make([]uint64, 0, len(hint.Indices)-1)
			for _, idx := range hint.Indices {
				if idx == x {
					continue
				}
				indices = append(indices, idx)
			}

			return indices, hint, true
		}
	}

	return nil, nil, false
}
